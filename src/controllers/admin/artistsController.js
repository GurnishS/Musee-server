const createError = require('http-errors');
const { listArtists, getArtist, createArtist, updateArtist, deleteArtist } = require('../../models/artistModel');
const { createUser, updateUser } = require('../../models/userModel');
const { supabase, supabaseAdmin } = require('../../db/config');
const mime = require('mime-types');
const { uploadUserAvatarToStorage, uploadArtistCoverToStorage } = require('../../utils/supabaseStorage');

// --- helpers: sanitize inputs BEFORE any DB operation ---
function isUUID(v) {
    return typeof v === 'string' && /^[0-9a-fA-F-]{36}$/.test(v);
}

function toNum(v, def = null) {
    if (v === undefined || v === null || v === '') return def;
    const n = Number(v);
    return Number.isFinite(n) ? n : def;
}

function sanitizeUserCreateInput(body = {}) {
    const name = typeof body.name === 'string' ? body.name.trim() : '';
    const email = typeof body.email === 'string' ? body.email.trim() : '';
    const password = typeof body.password === 'string' ? body.password.trim() : body.password;
    if (!name) throw createError(400, 'name is required');
    if (!email) throw createError(400, 'email is required');
    // password may be auto-generated by user model if missing; allow undefined here
    return { name, email, password };
}

function sanitizeArtistCreateInput(body = {}) {
    const out = {};
    // bio, cover_url
    if (body.bio !== undefined) out.bio = typeof body.bio === 'string' ? body.bio.trim() : '';
    if (body.cover_url !== undefined) out.cover_url = typeof body.cover_url === 'string' ? body.cover_url.trim() : body.cover_url;

    // genres: accept array or CSV string
    if (Array.isArray(body.genres)) {
        out.genres = body.genres.map(String);
    } else if (typeof body.genres === 'string') {
        const t = body.genres.trim();
        out.genres = t ? (t.includes(',') ? t.split(',').map(s => s.trim()).filter(Boolean) : [t]) : [];
    }

    // debut_year: required, accept numeric string
    const debut = toNum(body.debut_year, null);
    if (debut === null || !Number.isFinite(debut) || Math.trunc(debut) <= 0) {
        throw createError(400, 'debut_year is required and must be a positive number');
    }
    out.debut_year = Math.trunc(debut);

    // is_verified: boolean or 'true'/'false'
    if (body.is_verified !== undefined) {
        out.is_verified = body.is_verified === true || body.is_verified === 'true';
    }

    // monthly_listeners: default 0
    out.monthly_listeners = Math.max(0, Math.trunc(toNum(body.monthly_listeners, 0)) || 0);

    // region_id: required UUID
    if (!isUUID(body.region_id)) throw createError(400, 'region_id (UUID) is required');
    out.region_id = body.region_id;

    // date_of_birth: pass through, allow ISO/date string
    if (body.date_of_birth !== undefined) out.date_of_birth = body.date_of_birth;

    // social_links: object or JSON string
    if (body.social_links !== undefined) {
        if (typeof body.social_links === 'string') {
            try { out.social_links = JSON.parse(body.social_links); }
            catch { throw createError(400, 'social_links must be valid JSON'); }
        } else if (body.social_links && typeof body.social_links === 'object') {
            out.social_links = body.social_links;
        } else {
            throw createError(400, 'social_links must be an object');
        }
    }

    return out;
}

async function list(req, res) {
    const limit = Math.min(100, Number(req.query.limit) || 20);
    const page = Math.max(0, Number(req.query.page) || 0);
    const q = req.query.q || undefined;
    const offset = page * limit;
    const { items, total } = await listArtists({ limit, offset, q });
    res.json({ items, total, page, limit });
}

async function getOne(req, res) {
    const { id } = req.params;
    const item = await getArtist(id);
    if (!item) throw createError(404, 'Artist not found');
    res.json(item);
}

async function create(req, res) {
    // Sanitize inputs BEFORE any DB operations
    const body = { ...req.body };
    const userInput = sanitizeUserCreateInput(body);
    const artistInput = sanitizeArtistCreateInput(body);

    // 1) Create auth user
    const authUser = await createUser(userInput);

    // 1a) If avatar file provided, upload and set on user
    const avatarFile = req.files?.avatar?.[0];
    if (avatarFile) {
        const avatarUrl = await uploadUserAvatarToStorage(authUser.id, avatarFile);
        if (avatarUrl) {
            try { await updateUser(authUser.id, { avatar_url: avatarUrl }); } catch { }
        }
    }

    // 2) Optionally update users table
    try {
        await updateUser(authUser.id, {
            subscription_type: body.subscription_type,
            plan_id: body.plan_id,
            settings: body.settings,
        });
    } catch (e) {
        console.warn('Optional user update after auth create failed:', e?.message || e);
    }

    // 3) Create artist with the new user id
    const artist = await createArtist({ ...artistInput, artist_id: authUser.id });

    // 4) Upload cover if provided and update
    const coverFile = req.files?.cover?.[0] || req.file;
    if (coverFile) {
        const coverUrl = await uploadArtistCoverToStorage(artist.artist_id, coverFile);
        if (coverUrl) {
            const updated = await updateArtist(artist.artist_id, { cover_url: coverUrl });
            return res.status(201).json(updated);
        }
    }

    return res.status(201).json(artist);
}

async function update(req, res) {
    const { id } = req.params;
    const payload = { ...req.body };
    if (req.file) {
        const coverUrl = await uploadArtistCoverToStorage(id, req.file);
        if (coverUrl) payload.cover_url = coverUrl;
    }
    const item = await updateArtist(id, payload);
    res.json(item);
}

async function remove(req, res) {
    const { id } = req.params;
    const artist = await getArtist(id);
    if (!artist) {
        return res.status(404).json({ message: 'Artist not found' });
    }
    await deleteArtistCoverFromStorage(id, artist.cover_url);
    await deleteArtist(id);
    // Optionally downgrade user_type to 'listener' -- leave as-is for now
    res.status(204).send();
}

module.exports = { list, getOne, create, update, remove };
